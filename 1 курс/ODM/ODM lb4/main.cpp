#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include<iostream>
#include<conio.h>

using namespace std;

void peresechenie( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{

    int temp=0,size_c=0, i_c=-1,C_O[100];  ///cоздаем множество С_O
    //------------------------------------------------------------------------------

    for(int i=0; i<a_o; i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b_o; j++)///если j меньше b прибавляем к j единицу
        {
            if(A_O[i]==B_O[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {
                i_c++;
                size_c++;
                C_O[i_c]=A_O[i];///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    ///Множество С_O- пересечение множеств А_O и В_O.
    cout<<endl<<"----------------------------------------------"<<endl;
    cout<<"Пересечение соответствий: "<<endl;
    cout<<"область отправления: "<<endl;///выводим пересечение
    for( int i_c1=0; i_c1<size_c; i_c1++) cout<<C_O[i_c1]<<" ";  ///выводим на экран множество С_O
    cout<<endl;
    int C_P[100];  ///cоздаем множество С_P
    temp=0;size_c=0;i_c=-1;
    //------------------------------------------------------------------------------

    for(int i=0; i<a_p; i++)///если i меньше а_p прибавляем к i единицу
    {
        for(int j=0; j<b_p; j++)///если j меньше b_P прибавляем к j единицу
        {
            if(A_P[i]==B_P[j])///Если i-й элемент множества A_P и j-й элемент множества B_P равны
            {
                i_c++;
                size_c++;
                C_P[i_c]=A_P[i];///добавляем i-й элемент в множество C_P
                break;
            }

        }

    }
    ///Множество С_P- пересечение множеств А_P и В_P.
    cout<<"область прибытия: "<<endl;//выводим пересечение
    for( int i_c1=0; i_c1<size_c; i_c1++) cout<<C_P[i_c1]<<" ";  ///выводим на экран множество С_P
    cout<<endl;

    vector <vector<int> > C;  ///cоздаем график С
    //------------------------------------------------------------------------------

    for(int i=0; i<a; i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b; j++)///если j меньше b прибавляем к j единицу
        {
            if(A[i]==B[j])///Если i-й элемент графика A и j-й элемент график B равны
            {

                C.push_back(A[i]);///добавляем i-й элемент в график C
                break;
            }

        }

    }
    ///Множество С- пересечение множеств А и В.
    cout<<endl;
    cout<<"Граффик соответствия: "<<endl;//выводим пересечение
    cout<<"{";
    for (int i = 0; i < C.size(); i++)
    {
        cout<<"<";
        cout<<C[i][0];
        cout<<",";
        cout<<C[i][1];
        cout<<">";
    }
    cout<<"}"; ///выводим на экран множество С
    cout<<endl<<"----------------------------------------------"<<endl;
}

void Obedinenie( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{


///--------------------------------------------------------------------------
    int *C1_O; ///выделяем память под множество С1_O
    C1_O= new int[b_o]; ///х=b_O(мощность множества С1_O)
    for(int i=0; i<b_o; i++) C1_O[i]=B_O[i]; ///Создаём множество С1_O равное множеству В_O.
    for(int i=0; i<a_o; i++) ///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b_o; j++) ///если j меньше b_O прибавляем к b_O единицу
        {
            if(A_O[i]==C1_O[j])
            {
                C1_O[j]=0; ///Заменяем j элемент множества С1_O на 0.
                break;
            }

        }

    }
///--------------------------------------------------------------------------
    int *C1_P; ///выделяем память под множество С1_P
    C1_P= new int[b_p]; ///х=b(мощность множества С1_P)
    for(int i=0; i<b_p; i++) C1_P[i]=B_P[i]; ///Создаём множество С1_P равное множеству В_P.
    for(int i=0; i<a_p; i++) ///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b_p; j++) ///если j меньше b__P прибавляем к b_P единицу
        {
            if(A_P[i]==C1_P[j])
            {
                C1_P[j]=0; ///Заменяем j элемент множества С1_P на 0.
                break;
            }

        }

    }
    vector <vector<int> > C1(B); ///Создаём график С1 равное множеству В.
    for(int i=0; i<a; i++) ///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b; j++) ///если j меньше b прибавляем к b единицу
        {
            if(A[i]==C1[j])
            {
                C1[j][0]=0; ///Заменяем j элемент графика С1 на 0.
                break;
            }

        }

    }
  ///--------------------------------------------------------------------------
    vector <vector<int> > C(A); ///Cоздаем график С равное графику А.
    for(int i_b=0; i_b<b; i_b++) if(C1[i_b][0]!=0)
        {
            C.push_back(C1[i_b]);  ///Копируем элементы графика C1 не равные нулю в график С.
        }
    ///---------------------------------------------------------------


    cout<<endl<<"----------------------------------------------"<<endl;
    cout<<"объединение соответствий:"<<endl; ///С-объединение графиков.
    cout<<"область отправления: "<<endl;///выводим пересечение
    for(int i=0; i<a_o; i++) cout<<A_O[i]<<" ";
    for(int i=0; i<b_o; i++) if(C1_O[i]!=0) ///выводим пересечение области отправления
        {
            cout<<C1_O[i]<<" ";

        }
    cout<<endl;
    cout<<"область прибытия: "<<endl;///выводим пересечение области прибытия
    for(int i=0; i<a_p; i++) cout<<A_P[i]<<" ";
    for(int i=0; i<b_p; i++) if(C1_P[i]!=0)
        {
            cout<<C1_P[i]<<" ";

        }
    cout<<endl;///выводим пересечение
    cout<<"{";///выводим пересечение
    for (int i = 0; i < C.size(); i++)
    {
        cout<<"<";
        cout<<C[i][0];///выводим пересечение
        cout<<",";
        cout<<C[i][1];///выводим пересечение
        cout<<">";
    }
    cout<<"}"; ///выводим на экран множество С
    cout<<endl<<"----------------------------------------------"<<endl;



}
void sem_razn( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    ///------------------------------------------------------------------
    int *C6_O; ///выделяем память под множество С6_O
    C6_O= new int[a_o];///мощность С6_O равна а_O
    for(int i=0; i<a_o; i++) C6_O[i]=A_O[i]; ///Создаем множество С6_O равное множеству А_O
    for(int i=0; i<b_o; i++)
    {
        for(int j=0; j<a_o; j++)
        {
            if(B_O[i]==C6_O[j]) ///Если i-ый элемент множества B_O равен j-ому элементу множества С6_O
            {
                C6_O[j]=0; ///Заменяем j элемент С6_O на 0
                break;
            }

        }

    }
    int *C7_O; ///выделяем память для множества С7_O
    C7_O= new int[b_o]; ///мощность С7_O равна В
    for(int i_a=0; i_a<a_o; i_a++) C7_O[i_a]=B_O[i_a]; ///Создаем множество С7_O равное множеству В_O
    for(int i=0; i<b_o; i++) ///если i меньше b увеличиваем i на 1
    {
        for(int j=0; j<a_o; j++) ///если j меньше a увеличиваем j на 1
        {
            if(A_O[i]==C7_O[j]) ///Если i-ый элемент множества А_O равен j-ому элементу множества С7_O
            {
                C7_O[j]=0; ///заменяем j элемент множества С7_O на 0
                break;
            }

        }

    }
    ///--------------------------------------------------------------------------------------------------------------
    int *C6_P; ///выделяем память под множество С6_P
    C6_P= new int[a_p];///мощность С6_P равна а
    for(int i=0; i<a_p; i++) C6_P[i]=A_P[i]; ///Создаем множество С6_P равное множеству А_P
    for(int i=0; i<b_p; i++)
    {
        for(int j=0; j<a_p; j++)
        {
            if(B_P[i]==C6_P[j]) ///Если i-ый элемент множества B_P равен j-ому элементу множества С6_P
            {
                C6_P[j]=0; ///Заменяем j элемент С6_P на 0
                break;
            }

        }

    }
    int *C7_P; ///выделяем память для множества С7_P
    C7_P= new int[b_p]; ///мощность С7_P равна В
    for(int i_a=0; i_a<a_p; i_a++) C7_P[i_a]=B_P[i_a]; ///Создаем множество С7_P равное множеству В
    for(int i=0; i<b_p; i++) ///если i меньше b увеличиваем i на 1
    {
        for(int j=0; j<a_p; j++) ///если j меньше a увеличиваем j на 1
        {
            if(A_P[i]==C7_P[j]) ///Если i-ый элемент множества А_P равен j-ому элементу множества С7_P
            {
                C7_P[j]=0; ///заменяем j элемент множества С7_P на 0
                break;
            }

        }

    }
    ///--------------------------------------------------------------------------------------------------------------
    vector <vector<int> > C6(A); ///Создаем множество С6 равное множеству А
    for(int i=0; i<b; i++)
    {
        for(int j=0; j<a; j++)
        {
            if(B[i]==C6[j]) ///Если i-ый элемент множества B равен j-ому элементу множества С6
            {
                C6[j][0]=0; ///Заменяем j элемент С6 на 0
                break;
            }

        }

    }
    vector <vector<int> > C7(B); ///Создаем множество С7 равное множеству В
    for(int i=0; i<b; i++) ///если i меньше b увеличиваем i на 1
    {
        for(int j=0; j<a; j++) ///если j меньше a увеличиваем j на 1
        {
            if(A[i]==C7[j]) ///Если i-ый элемент множества А равен j-ому элементу множества С7
            {
                C7[j][0]=0; ///заменяем j элемент множества С7 на 0
                break;
            }

        }

    }

    cout<<endl<<"----------------------------------------------"<<endl;
    cout<<"симметрическая разность соответствий:"<<endl;
    cout<<"область отправления: "<<endl;//выводим пересечение
    for(int i_a=0; i_a<a_o; i_a++) if(C6_O[i_a]!=0) cout<<C6_O[i_a]<<" ";///выводим симметрическую разность области отправления на экран
    for(int i_a=0; i_a<a_o; i_a++) if(C7_O[i_a]!=0) cout<<C7_O[i_a]<<" ";
    cout<<endl<<"----------------------------------------------"<<endl;///выводим симметрическую разность на экран
    delete[] C6_O;
    delete[] C7_O;
    cout<<"область прибытия: "<<endl;//выводим пересечение
    for(int i_a=0; i_a<a_p; i_a++) if(C6_P[i_a]!=0) cout<<C6_P[i_a]<<" ";///выводим симметрическую разность области прибытия на экран
    for(int i_a=0; i_a<a_p; i_a++) if(C7_P[i_a]!=0) cout<<C7_P[i_a]<<" ";///выводим симметрическую разность на экран
    cout<<endl<<"----------------------------------------------"<<endl;///выводим симметрическую разность на экран
    delete[] C6_P;
    delete[] C7_P;
  cout<<"график соответствия:"<<endl; ///выводим симметрическую разность на экран
  cout<<"{";
    for (int i = 0; i < C6.size(); i++)///выводим симметрическую разность на экран
    {
        if(C6[i][0]!=0)///выводим симметрическую разность на экран
        {cout<<"<";
        cout<<C6[i][0];///выводим симметрическую разность на экран
        cout<<",";
        cout<<C6[i][1];///выводим симметрическую разность на экран
        cout<<">";}
    }
    for (int i = 0; i < C7.size(); i++)///выводим симметрическую разность на экран
    {
        if(C7[i][0]!=0)
        {cout<<"<";
        cout<<C7[i][0];///выводим симметрическую разность на экран
        cout<<",";
        cout<<C7[i][1];///выводим симметрическую разность на экран
        cout<<">";}
    }
    cout<<"}"; ///выводим симметрическую разность на экран
    cout<<endl<<"----------------------------------------------"<<endl;


}
void Raznost( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    ///-----------------------------------------------------------------------
    int *C2_O; ///выделяем память под множество С2_O
    C2_O= new int[a_o];  ///х=а(мощность множества С2_O).
    for(int i_a=0; i_a<a_o; i_a++) C2_O[i_a]=A_O[i_a];   ///Создаём множество С2_O равное множеству А.
    for(int j=0; j<b_o; j++) ///если j<b увеличиваем j на единицу
    {
        for(int i=0; i<a_o; i++) ///если i<b увеличиваем i на единицу
        {
            if(B_O[i]==C2_O[j]) ///Если i-ый элемент множества A_O равен j-ому элементу множества С2_O
            {
                C2_O[j]=0; ///Заменяем j элемент множества С2_O на 0
                break;
            }

        }

    }
    ///-----------------------------------------------------------------------
    int *C2_P; ///выделяем память под множество С2_P
    C2_P= new int[a_p];  ///х=а(мощность множества С2_P).
    for(int i_a=0; i_a<a_p; i_a++) C2_P[i_a]=A_P[i_a];   ///Создаём множество С2_P равное множеству А.
    for(int j=0; j<b_p; j++) ///если j<b увеличиваем j на единицу
    {
        for(int i=0; i<a_p; i++) ///если i<b увеличиваем i на единицу
        {
            if(B_P[i]==C2_P[j]) ///Если i-ый элемент множества A_P равен j-ому элементу множества С2_P
            {
                C2_P[j]=0; ///Заменяем j элемент множества С2_P на 0
                break;
            }

        }

    }
    ///-----------------------------------------------------------------------
    vector <vector<int> > C2(A);   ///Создаём график С2 равное графику А.
    for(int j=0; j<b; j++) ///если j<b увеличиваем j на единицу
    {
        for(int i=0; i<a; i++) ///если i<b увеличиваем i на единицу
        {
            if(B[i]==C2[j]) ///Если i-ый элемент графика A равен j-ому элементу графика С2
            {
                C2[j][0]=0; ///Заменяем j элемент графика С2 на 0
                break;
            }

        }
    }
    ///--------------------------------------------------------------------------
    cout<<endl<<"Разность отношений равна: "<<endl;///выводим разность на экран
    cout<<"область отправления: "<<endl;
    for(int i_a=0; i_a<a_o; i_a++) if(C2_O[i_a]!=0) cout<<C2_O[i_a]<<" "; ///выводим разность на экран
    cout<<endl<<"область прибытия: "<<endl;
    for(int i_a=0; i_a<a_p; i_a++) if(C2_P[i_a]!=0) cout<<C2_P[i_a]<<" "; ///выводим разность на экран
    cout<<endl<<"график соответствия: "<<endl;///выводим разность на экран
      cout<<"{";
    for (int i = 0; i < C2.size(); i++)///выводим разность на экран
    {
        if(C2[i][0]!=0)///выводим разность на экран
        {cout<<"<";
        cout<<C2[i][0];///выводим разность на экран
        cout<<",";
        cout<<C2[i][1];///выводим разность на экран
        cout<<">";}
    }
    cout<<"}"; ///выводим разность на экран
    cout<<endl<<"----------------------------------------------"<<endl;
}

void inversion( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
 vector <vector<int> > C8(A); ///Создаем множество С8 равное множеству А
  for(int i=0;i<C8.size();i++)
  {
      swap(C8[i][0],C8[i][1]); ///меняем местами первый и второй элементы кортежа графика соответствия
  }
   cout<<"инверсия соответствия Г1:"<<endl;
   cout<<"область отправления:"<<endl;
   for(int i=0; i<a_p; i++) cout<<A_P[i]<<" "; ///Область отправления равна обласи прибытия
   cout<<endl<<"область прибытия:"<<endl;
   for(int i=0; i<a_o; i++) cout<<A_O[i]<<" ";///Область прибытия равна обласи отправления
   cout<<endl<<"график соответствия:"<<endl;
   cout<<"{"; ///выводим инверсию на экран
    for (int i = 0; i < C8.size(); i++)
    {
        cout<<"<";
        cout<<C8[i][0];///выводим инверсию на экран
        cout<<",";
        cout<<C8[i][1];///выводим инверсию на экран
        cout<<">";
    }
    cout<<"}"; ///выводим инверсию на экран
    cout<<endl<<"----------------------------------------------"<<endl;
}
void Composition( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    int tmp=a;
  if(b<a) tmp=b;
  vector <vector<int> > C9(A);///Создаем множество С8 равное множеству А
  for(int i=0;i<tmp;i++)
  {
      C9[i][1]=B[i][1]; ///заменяем вторые компоненты i-го кортежа графика С9 на вторые компоненты i-го кортежа графика В
  }
cout<<"композиция Г1 и Г2:"<<endl;
   cout<<"область отправления:"<<endl;
   for(int i=0; i<a_o; i++) cout<<A_O[i]<<" "; ///область отправления равна области отправления первого графика
   cout<<endl<<"область прибытия:"<<endl;
   for(int i=0; i<b_p; i++) cout<<B_P[i]<<" "; ///область прибытия равна области прибытия первого графика
cout<<endl<<"График соответствия:"<<endl;
   cout<<"{"; ///выводим композицию на экран
    for (int i = 0; i < tmp; i++)
    {
        cout<<"<";
        cout<<C9[i][0];///выводим композицию на экран
        cout<<",";
        cout<<C9[i][1];///выводим композицию на экран
        cout<<">";
    }
    cout<<"}"; ///выводим композицию на экран
    cout<<endl<<"----------------------------------------------"<<endl;
}

void obraz1( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    int n=0;
    cout<<"Введите мощность множества E: "; cin>>n;/// задаем мощность множества Е
    int *E; /// создаем множество Е
    E= new int[n]; ///выделяем память под множество Е
   cout<<endl<<"Введите элементы множества E: ";
   for(int i=0;i<n;i++) cin>>E[i]; ///вводим элементы Е
   vector <vector<int> > D(n*a_p);

    int e=0;
    for(int i_a=0; i_a<n; i_a++) ///если i<a увеличиваем i на 1
        for(int i_b=0; i_b<a_p; i_b++) ///если j<b увеличиваем i на 1
        {
            D[e].push_back(E[i_a]); ///добавляем первый элемент кортежа
            D[e].push_back(A_P[i_b]); ///добавляем второй элемент кортежа элемент кортежа
            e++;    ///переходим к следующему кортежу
        }


    vector <vector<int> > C;  ///cоздаем график С
    //------------------------------------------------------------------------------

    for(int i=0; i<D.size(); i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<a; j++)///если j меньше b прибавляем к j единицу
        {
            if(D[i]==A[j])///Если i-й элемент графика A и j-й элемент графика B равны
            {

                C.push_back(D[i]);///добавляем i-й элемент в график C
                break;
            }

        }

    }
    cout<<"{ ";
    for(int i=0;i<C.size();i++) cout<<C[i][1]<<" "; ///находим вторую проекцию
    cout<<"}";   ///выводим проекцию на экран
    cout<<endl<<"----------------------------------------------"<<endl;
    delete []E;
}

void proobraz1( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    int n=0;
    cout<<"Введите мощность множества E: "; cin>>n; /// задаем мощность множества Е
    int *E; /// создаем множество Е
    E= new int[n]; ///выделяем память под множество Е
   cout<<endl<<"Введите элементы множества E: ";
   for(int i=0;i<n;i++) cin>>E[i]; ///вводим элементы Е
   vector <vector<int> > D(n*a_o);

    int e=0;
    for(int i_a=0; i_a<a_o; i_a++) ///если i<a увеличиваем i на 1
        for(int i_b=0; i_b<n; i_b++) ///если j<b увеличиваем i на 1
        {
            D[e].push_back(A_O[i_a]); ///добавляем первый элемент кортежа
            D[e].push_back(E[i_b]);   ///добавляем второй элемент кортежа
            e++;
        }


    vector <vector<int> > C;  ///cоздаем множество С
    //------------------------------------------------------------------------------

    for(int i=0; i<D.size(); i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<a; j++)///если j меньше b прибавляем к j единицу
        {
            if(D[i]==A[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {
                C.push_back(D[i]);///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    cout<<"{ ";
    for(int i=0;i<C.size();i++) cout<<C[i][0]<<" "; ///находим первую проекцию графика
    cout<<"}"; ///выводим на экран
    cout<<endl<<"----------------------------------------------"<<endl;
    delete []E;
}


void obraz2( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    int n=0;
    cout<<"Введите мощность множества E: "; cin>>n; /// задаем мощность множества Е
    int *E; /// создаем множество Е
    E= new int[n]; ///выделяем память под множество Е
   cout<<endl<<"Введите элементы множества E: ";
   for(int i=0;i<n;i++) cin>>E[i]; ///вводим элементы Е
   vector <vector<int> > D(n*b_p);

    int e=0;
    for(int i_a=0; i_a<n; i_a++) ///если i<a увеличиваем i на 1
        for(int i_b=0; i_b<b_p; i_b++) ///если j<b увеличиваем i на 1
        {
            D[e].push_back(E[i_a]); ///добавляем первый элемент кортежа
            D[e].push_back(B_P[i_b]); ///добавляем второй элемент кортежа
            e++; ///преходим к следующему кортежу
        }


    vector <vector<int> > C;  ///cоздаем множество С
    //------------------------------------------------------------------------------

    for(int i=0; i<n*b_p; i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b; j++)///если j меньше b прибавляем к j единицу
        {
            if(D[i]==B[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {

                C.push_back(D[i]);///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    cout<<"{ ";
    for(int i=0;i<C.size();i++) cout<<C[i][1]<<" "; ///находим вторые проекции графика
    cout<<"}"; ///выводим на экран
    cout<<endl<<"----------------------------------------------"<<endl;
    delete []E;
}

void proobraz2( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    int n=0;
    cout<<"Введите мощность множества E: "; cin>>n; /// задаем мощность множества Е
    int *E; /// создаем множество Е
    E= new int[n]; ///выделяем память под множество Е
   cout<<endl<<"Введите элементы множества E: ";
   for(int i=0;i<n;i++) cin>>E[i]; ///вводим элементы Е
   vector <vector<int> > D(n*b_o);

    int e=0;
    for(int i_a=0; i_a<b; i_a++) ///если i<a увеличиваем i на 1
        for(int i_b=0; i_b<n; i_b++) ///если j<b увеличиваем i на 1
        {
            D[e].push_back(B_O[i_a]);///добавляем первый элемент кортежа
            D[e].push_back(E[i_b]); ///добавляем второй элемент кортежа
            e++; ///переходим к следующему
        }


    vector <vector<int> > C;  ///cоздаем множество С
    //------------------------------------------------------------------------------

    for(int i=0; i<n*b_o; i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b_o; j++)///если j меньше b прибавляем к j единицу
        {
            if(D[i]==B[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {
                C.push_back(D[i]);///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    cout<<"{ ";
    for(int i=0;i<C.size();i++) cout<<C[i][0]<<" "; ///находим проекции
    cout<<"}"; ///выводим на экран
    cout<<endl<<"----------------------------------------------"<<endl;
    delete []E;
}


int main()
{
    bool kol=true;   ///объявляем переменные
    int *A_O,*B_O,*A_P,*B_P; ///объявляем переменные
    setlocale(LC_ALL,"Russian"); ///подключаем поддержку русского языка
    int tmp1=0,tmp2=0;///объявляем переменные


    ///---------------------------------------------------------------------------------------------------------------
    cout<<"введите мощность обсасти отправления соответствия Г1: ";
    int a_o; cin>>a_o;
    A_O= new int[a_o];  ///динамически выделяем память для множества А_O
    cout<<endl;
    cout<<"введите  обсасть отправления соответствия Г1: ";
    for (int i = 0; i < a_o; i++) cin>>A_O[i]; ///Пользователь задает элементы множества А_O
    cout<<endl;
    cout<<"введите мощность обсасти прибытия соответствия Г1: ";
    int a_p; cin>>a_p;
    A_P= new int[a_p];  ///динамически выделяем память для множества A_P
    cout<<endl;
    cout<<"введите  обсасть прибытия соответствия Г1: ";
    for (int i = 0; i < a_p; i++) cin>>A_P[i]; ///Пользователь задает элементы множества A_P.
    cout<<endl;
    cout<<"Ведите мощность графика соответствия Г1: " ;
    int a;                                  ///Пользователь задает мощность графика A (a)
    cin>>a;
    vector <vector<int> > A(a);
    cout<<"введите кортежи графика соответствия Г1: ";
    cout<<endl;
    for (int i = 0; i < a; i++) ///пользователь вводит кортежи графика А
    {
        cout<<i+1<<" "<<"кортеж:";
        cout<<endl;
        tmp1=0;///пользователь вводит кортежи графика А
        tmp2=0;///пользователь вводит кортежи графика А
        cin>>tmp1;
        A[i].push_back(tmp1);///пользователь вводит кортежи графика А
        cin>>tmp2;
        A[i].push_back(tmp2);///пользователь вводит кортежи графика А
    }
    cout<<endl;
  ///---------------------------------------------------------------------------------------------------------------



  ///---------------------------------------------------------------------------------------------------------------
    cout<<"введите мощность обсасти отправления соответствия Г2: ";
    int b_o; cin>>b_o;
    B_O= new int[b_o];  ///динамически выделяем память для множества B_O
    cout<<endl;
    cout<<"введите  обсасть отправления соответствия Г2: ";
    for (int i = 0; i < b_o; i++) cin>>B_O[i]; ///Пользователь задает элементы B_O.
    cout<<endl;
    cout<<"введите мощность обсасти прибытия соответствия Г2: ";
    int b_p; cin>>b_p;
    B_P= new int[b_p];  ///динамически выделяем память для множества B_P
    cout<<endl;
    cout<<"введите  обсасть прибытия соответствия Г2: ";
    for (int i = 0; i < b_p; i++) cin>>B_P[i]; ///Пользователь задает элементы B_P.
    cout<<endl;
    cout<<"Ведите мощность графика соответствия Г2: ";
    int b;
    cin>>b;                                ///Пользователь задает мощность графика B (b)
    vector <vector<int> > B(b);
    cout<<"введите кортежи графика соответствия Г2: ";
    cout<<endl;
    for (int i = 0; i < b; i++)
    {
        cout<<i+1<<" "<<"кортеж:";///пользователь вводит кортежи графика А
        cout<<endl;
        tmp1=0;///пользователь вводит кортежи графика А
        tmp2=0;
        cin>>tmp1;///пользователь вводит кортежи графика А
        B[i].push_back(tmp1);///пользователь вводит кортежи графика А
        cin>>tmp2;
        B[i].push_back(tmp2);///пользователь вводит кортежи графика А
    }
    cout<<endl;


    ///---------------------------------------------------------------------------------------------------------------
    system("cls"); ///очищаем экран


   ///---------------------------------------------------------------------------------------------------------------


    cout<<"обсасть отправления соответствия Г1: ";
    for (int i = 0; i < a_o; i++) cout<<A_O[i]<<" "; ///выводим на экран область отправления Г1
    cout<<endl;
    cout<<"обсасть прибытия соответствия А: ";
    for (int i = 0; i < a_p; i++) cout<<A_P[i]<<" "; ///выводим на экран область прибытия Г1
    cout<<endl;
     cout<<"графика соответствия А: "; ///выводим на экран график Г1
    cout<<"{";
    for (int i = 0; i < a; i++)///выводим на экран график Г1
    {
        cout<<"<";///выводим на экран график Г1
        cout<<A[i][0];///выводим на экран график Г1
        cout<<",";///выводим на экран график Г1
        cout<<A[i][1];///выводим на экран график Г1
        cout<<">";///выводим на экран график Г1
    }
    cout<<"}";
    cout<<endl;
   ///---------------------------------------------------------------------------------------------------------------
    cout<<"обсасть отправления соответствия Г2: ";
    for (int i = 0; i < b_o; i++) cout<<B_O[i]<<" ";///выводим на экран область отправления Г2
    cout<<endl;
    cout<<"обсасть прибытия соответствия B: ";
    for (int i = 0; i < b_p; i++) cout<<B_P[i]<<" "; ///выводим на экран область прибытия Г2
    cout<<endl;
    cout<<"графика соответствия B: "; ///выводим на экран график Г1
    cout<<"{";
    for (int i = 0; i < b; i++)///выводим на экран график Г1
    {
        cout<<"<";///выводим на экран график Г1
        cout<<B[i][0];///выводим на экран график Г1
        cout<<",";///выводим на экран график Г1
        cout<<B[i][1];///выводим на экран график Г1
        cout<<">";
    }
    cout<<"}";///выводим на экран график Г1
    cout<<endl;
    ///---------------------------------------------------------------------------------------------------------
    cout<<endl;
     int in;
    ///Пользователь выбирает операцию над множествами-------------------------------------------------------------
        while(kol)
        {

            cout << "1.Операция пересечения АВ." << endl; ///выводим на экран название опрецации
            cout << "2.Операция объединения АВ." << endl; ///выводим на экран название опрецации
            cout << "3.Операция разность АВ." << endl;   ///выводим на экран название опрецации
            cout << "4.Операция инверсии А." << endl;///выводим на экран название опрецации
            cout << "5.Операция композиции АВ." <<endl;///выводим на экран название опрецации
            cout << "6.Операция симметрическоф разности." << endl;///выводим на экран название опрецации
            cout << "7.Операция образа Г1." << endl;///выводим на экран название опрецации
            cout << "8.Операция прообраза Г1." << endl;///выводим на экран название опрецации
            cout << "9.Операция образа Г2." << endl;///выводим на экран название опрецации
            cout << "10.Операция прообраза Г2." << endl;///выводим на экран название опрецации
            cout << "11.Завершить программу." << endl;///выводим на экран название опрецации
            cin >> in; ///выбираем операцию
            switch (in)
            {
            case 1:
        {
            peresechenie(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///пересечение
            break;
        }
            case 2:
        {
            Obedinenie(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///объединение
            break;
        }
            case 3:
        {
            Raznost(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///разность
            break;
        }
        case 4:
        {
            inversion(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);      ///инверсия
            break;
        }
        case 5:
        {
            Composition(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///композиция
            break;
        }
        case 6:
        {
            sem_razn(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///симметрическая разность
            break;
        }
        case 7:
        {
            obraz1(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///образ Г1
            break;
        }
        case 8:
        {
            proobraz1(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///прообраз Г1
            break;
        }
        case 9:
        {
            obraz2(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///образ Г2
            break;
        }
        case 10:
        {
            proobraz2(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///прообраз Г2
            break;
        }
        case 11:
        {
            kol=false;    ///завершение работы
            break;
        }
            default:
        {
            cout<<"Error!! ";    ///ошибка при вводе
            break;
        }
            }

        }
    ///---------------------------------------------------------------------------------------------------------




    return 0;
}
