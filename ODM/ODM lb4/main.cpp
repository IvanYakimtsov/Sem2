#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include<iostream>
#include<conio.h>

using namespace std;

void peresechenie( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{

    int temp=0,size_c=0, i_c=-1,C_O[100];  ///cоздаем множество С
    //------------------------------------------------------------------------------

    for(int i=0; i<a_o; i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b_o; j++)///если j меньше b прибавляем к j единицу
        {
            if(A_O[i]==B_O[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {
                i_c++;
                size_c++;
                C_O[i_c]=A_O[i];///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    ///Множество С- пересечение множеств А и В.
    cout<<endl<<"----------------------------------------------"<<endl;
    cout<<"Пересечение соответствий: "<<endl;
    cout<<"область отправления: "<<endl;//выводим пересечение
    for( int i_c1=0; i_c1<size_c; i_c1++) cout<<C_O[i_c1]<<" ";  ///выводим на экран множество С
    cout<<endl;
    int C_P[100];  ///cоздаем множество С
    temp=0;size_c=0;i_c=-1;
    //------------------------------------------------------------------------------

    for(int i=0; i<a_p; i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b_p; j++)///если j меньше b прибавляем к j единицу
        {
            if(A_P[i]==B_P[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {
                i_c++;
                size_c++;
                C_P[i_c]=A_P[i];///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    ///Множество С- пересечение множеств А и В.
    cout<<"область прибытия: "<<endl;//выводим пересечение
    for( int i_c1=0; i_c1<size_c; i_c1++) cout<<C_P[i_c1]<<" ";  ///выводим на экран множество С
    cout<<endl;

    vector <vector<int> > C;  ///cоздаем множество С
    //------------------------------------------------------------------------------

    for(int i=0; i<a; i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b; j++)///если j меньше b прибавляем к j единицу
        {
            if(A[i]==B[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {

                C.push_back(A[i]);///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    ///Множество С- пересечение множеств А и В.
    cout<<endl;
    cout<<"Граффик соответствия: "<<endl;//выводим пересечение
    cout<<"{";
    for (int i = 0; i < C.size(); i++)
    {
        cout<<"<";
        cout<<C[i][0];
        cout<<",";
        cout<<C[i][1];
        cout<<">";
    }
    cout<<"}"; ///выводим на экран множество С
    cout<<endl<<"----------------------------------------------"<<endl;
}

void Obedinenie( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{


///--------------------------------------------------------------------------
    int *C1_O; ///выделяем память под множество С1
    C1_O= new int[b_o]; ///х=b(мощность множества С1)
    for(int i=0; i<b_o; i++) C1_O[i]=B_O[i]; ///Создаём множество С1 равное множеству В.
    for(int i=0; i<a_o; i++) ///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b_o; j++) ///если j меньше b прибавляем к b единицу
        {
            if(A_O[i]==C1_O[j])
            {
                C1_O[j]=0; ///Заменяем j элемент множества С1 на 0.
                break;
            }

        }

    }
///--------------------------------------------------------------------------
    int *C1_P; ///выделяем память под множество С1
    C1_P= new int[b_p]; ///х=b(мощность множества С1)
    for(int i=0; i<b_p; i++) C1_P[i]=B_P[i]; ///Создаём множество С1 равное множеству В.
    for(int i=0; i<a_p; i++) ///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b_p; j++) ///если j меньше b прибавляем к b единицу
        {
            if(A_P[i]==C1_P[j])
            {
                C1_P[j]=0; ///Заменяем j элемент множества С1 на 0.
                break;
            }

        }

    }
    vector <vector<int> > C1(B); ///Создаём множество С1 равное множеству В.
    for(int i=0; i<a; i++) ///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b; j++) ///если j меньше b прибавляем к b единицу
        {
            if(A[i]==C1[j])
            {
                C1[j][0]=0; ///Заменяем j элемент множества С1 на 0.
                break;
            }

        }

    }
  ///--------------------------------------------------------------------------
    vector <vector<int> > C(A); ///Cоздаем множество С равное множеству А.
    for(int i_b=0; i_b<b; i_b++) if(C1[i_b][0]!=0)
        {
            C.push_back(C1[i_b]);  ///Копируем элементы множество C1 не равные нулю в множество С.
        }
    ///---------------------------------------------------------------


    cout<<endl<<"----------------------------------------------"<<endl;
    cout<<"объединение соответствий:"<<endl; ///С-объединение множеств.
    cout<<"область отправления: "<<endl;//выводим пересечение
    for(int i=0; i<a_o; i++) cout<<A_O[i]<<" ";
    for(int i=0; i<b_o; i++) if(C1_O[i]!=0)
        {
            cout<<C1_O[i]<<" ";

        }
    cout<<endl;
    cout<<"область прибытия: "<<endl;//выводим пересечение
    for(int i=0; i<a_p; i++) cout<<A_P[i]<<" ";
    for(int i=0; i<b_p; i++) if(C1_P[i]!=0)
        {
            cout<<C1_P[i]<<" ";

        }
    cout<<endl;
    cout<<"{";
    for (int i = 0; i < C.size(); i++)
    {
        cout<<"<";
        cout<<C[i][0];
        cout<<",";
        cout<<C[i][1];
        cout<<">";
    }
    cout<<"}"; ///выводим на экран множество С
    cout<<endl<<"----------------------------------------------"<<endl;



}
void sem_razn( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    ///------------------------------------------------------------------
    int *C6_O; ///выделяем память под множество С6
    C6_O= new int[a_o];///мощность С6 равна а
    for(int i=0; i<a_o; i++) C6_O[i]=A_O[i]; ///Создаем множество С6 равное множеству А
    for(int i=0; i<b_o; i++)
    {
        for(int j=0; j<a_o; j++)
        {
            if(B_O[i]==C6_O[j]) ///Если i-ый элемент множества B равен j-ому элементу множества С6
            {
                C6_O[j]=0; ///Заменяем j элемент С6 на 0
                break;
            }

        }

    }
    int *C7_O; ///выделяем память для множества С7
    C7_O= new int[b_o]; ///мощность С7 равна В
    for(int i_a=0; i_a<a_o; i_a++) C7_O[i_a]=B_O[i_a]; ///Создаем множество С7 равное множеству В
    for(int i=0; i<b_o; i++) ///если i меньше b увеличиваем i на 1
    {
        for(int j=0; j<a_o; j++) ///если j меньше a увеличиваем j на 1
        {
            if(A_O[i]==C7_O[j]) ///Если i-ый элемент множества А равен j-ому элементу множества С7
            {
                C7_O[j]=0; ///заменяем j элемент множества С7 на 0
                break;
            }

        }

    }
    ///--------------------------------------------------------------------------------------------------------------
    int *C6_P; ///выделяем память под множество С6
    C6_P= new int[a_p];///мощность С6 равна а
    for(int i=0; i<a_p; i++) C6_P[i]=A_P[i]; ///Создаем множество С6 равное множеству А
    for(int i=0; i<b_p; i++)
    {
        for(int j=0; j<a_p; j++)
        {
            if(B_P[i]==C6_P[j]) ///Если i-ый элемент множества B равен j-ому элементу множества С6
            {
                C6_P[j]=0; ///Заменяем j элемент С6 на 0
                break;
            }

        }

    }
    int *C7_P; ///выделяем память для множества С7
    C7_P= new int[b_p]; ///мощность С7 равна В
    for(int i_a=0; i_a<a_p; i_a++) C7_P[i_a]=B_P[i_a]; ///Создаем множество С7 равное множеству В
    for(int i=0; i<b_p; i++) ///если i меньше b увеличиваем i на 1
    {
        for(int j=0; j<a_p; j++) ///если j меньше a увеличиваем j на 1
        {
            if(A_P[i]==C7_P[j]) ///Если i-ый элемент множества А равен j-ому элементу множества С7
            {
                C7_P[j]=0; ///заменяем j элемент множества С7 на 0
                break;
            }

        }

    }
    ///--------------------------------------------------------------------------------------------------------------
    vector <vector<int> > C6(A); ///Создаем множество С6 равное множеству А
    for(int i=0; i<b; i++)
    {
        for(int j=0; j<a; j++)
        {
            if(B[i]==C6[j]) ///Если i-ый элемент множества B равен j-ому элементу множества С6
            {
                C6[j][0]=0; ///Заменяем j элемент С6 на 0
                break;
            }

        }

    }
    vector <vector<int> > C7(B); ///Создаем множество С7 равное множеству В
    for(int i=0; i<b; i++) ///если i меньше b увеличиваем i на 1
    {
        for(int j=0; j<a; j++) ///если j меньше a увеличиваем j на 1
        {
            if(A[i]==C7[j]) ///Если i-ый элемент множества А равен j-ому элементу множества С7
            {
                C7[j][0]=0; ///заменяем j элемент множества С7 на 0
                break;
            }

        }

    }

    cout<<endl<<"----------------------------------------------"<<endl;
    cout<<"симметрическая разность соответствий:"<<endl; ///С-объединение множеств.
    cout<<"область отправления: "<<endl;//выводим пересечение
    for(int i_a=0; i_a<a_o; i_a++) if(C6_O[i_a]!=0) cout<<C6_O[i_a]<<" ";
    for(int i_a=0; i_a<a_o; i_a++) if(C7_O[i_a]!=0) cout<<C7_O[i_a]<<" ";
    cout<<endl<<"----------------------------------------------"<<endl;
    delete[] C6_O;
    delete[] C7_O;
    cout<<"область прибытия: "<<endl;//выводим пересечение
    for(int i_a=0; i_a<a_p; i_a++) if(C6_P[i_a]!=0) cout<<C6_P[i_a]<<" ";
    for(int i_a=0; i_a<a_p; i_a++) if(C7_P[i_a]!=0) cout<<C7_P[i_a]<<" ";
    cout<<endl<<"----------------------------------------------"<<endl;
    delete[] C6_P;
    delete[] C7_P;
  cout<<"график соответствия:"<<endl; ///выводим симметрическую разность на экран
  cout<<"{";
    for (int i = 0; i < C6.size(); i++)
    {
        if(C6[i][0]!=0)
        {cout<<"<";
        cout<<C6[i][0];
        cout<<",";
        cout<<C6[i][1];
        cout<<">";}
    }
    for (int i = 0; i < C7.size(); i++)
    {
        if(C7[i][0]!=0)
        {cout<<"<";
        cout<<C7[i][0];
        cout<<",";
        cout<<C7[i][1];
        cout<<">";}
    }
    cout<<"}"; ///выводим симметрическую разность на экран
    cout<<endl<<"----------------------------------------------"<<endl;


}
void Raznost( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    ///-----------------------------------------------------------------------
    int *C2_O; ///выделяем память под множество С2
    C2_O= new int[a_o];  ///х=а(мощность множества С2).
    for(int i_a=0; i_a<a_o; i_a++) C2_O[i_a]=A_O[i_a];   ///Создаём множество С2 равное множеству А.
    for(int j=0; j<b_o; j++) ///если j<b увеличиваем j на единицу
    {
        for(int i=0; i<a_o; i++) ///если i<b увеличиваем i на единицу
        {
            if(B_O[i]==C2_O[j]) ///Если i-ый элемент множества A равен j-ому элементу множества С2
            {
                C2_O[j]=0; ///Заменяем j элемент множества С2 на 0
                break;
            }

        }

    }
    ///-----------------------------------------------------------------------
    int *C2_P; ///выделяем память под множество С2
    C2_P= new int[a_p];  ///х=а(мощность множества С2).
    for(int i_a=0; i_a<a_p; i_a++) C2_P[i_a]=A_P[i_a];   ///Создаём множество С2 равное множеству А.
    for(int j=0; j<b_p; j++) ///если j<b увеличиваем j на единицу
    {
        for(int i=0; i<a_p; i++) ///если i<b увеличиваем i на единицу
        {
            if(B_P[i]==C2_P[j]) ///Если i-ый элемент множества A равен j-ому элементу множества С2
            {
                C2_P[j]=0; ///Заменяем j элемент множества С2 на 0
                break;
            }

        }

    }
    ///-----------------------------------------------------------------------
    vector <vector<int> > C2(A);   ///Создаём множество С2 равное множеству А.
    for(int j=0; j<b; j++) ///если j<b увеличиваем j на единицу
    {
        for(int i=0; i<a; i++) ///если i<b увеличиваем i на единицу
        {
            if(B[i]==C2[j]) ///Если i-ый элемент множества A равен j-ому элементу множества С2
            {
                C2[j][0]=0; ///Заменяем j элемент множества С2 на 0
                break;
            }

        }
    }
    ///--------------------------------------------------------------------------
    cout<<endl<<"Разность отношений равна: "<<endl;
    cout<<"область отправления: "<<endl;
    for(int i_a=0; i_a<a_o; i_a++) if(C2_O[i_a]!=0) cout<<C2_O[i_a]<<" "; ///выводим разность на экран
    cout<<endl<<"область прибытия: "<<endl;
    for(int i_a=0; i_a<a_p; i_a++) if(C2_P[i_a]!=0) cout<<C2_P[i_a]<<" "; ///выводим разность на экран
    cout<<endl<<"график соответствия: "<<endl;
      cout<<"{";
    for (int i = 0; i < C2.size(); i++)
    {
        if(C2[i][0]!=0)
        {cout<<"<";
        cout<<C2[i][0];
        cout<<",";
        cout<<C2[i][1];
        cout<<">";}
    }
    cout<<"}"; ///выводим разность на экран
    cout<<endl<<"----------------------------------------------"<<endl;
}

void inversion( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
 vector <vector<int> > C8(A); ///Создаем множество С8 равное множеству А
  for(int i=0;i<C8.size();i++)
  {
      swap(C8[i][0],C8[i][1]);
  }
   cout<<"инверсия соответствия Г1:"<<endl;
   cout<<"область отправления:"<<endl;
   for(int i=0; i<a_p; i++) cout<<A_P[i]<<" ";
   cout<<endl<<"область прибытия:"<<endl;
   for(int i=0; i<a_o; i++) cout<<A_O[i]<<" ";
   cout<<endl<<"график соответствия:"<<endl;
   cout<<"{"; ///выводим инверсию на экран
    for (int i = 0; i < C8.size(); i++)
    {
        cout<<"<";
        cout<<C8[i][0];
        cout<<",";
        cout<<C8[i][1];
        cout<<">";
    }
    cout<<"}"; ///выводим инверсию на экран
    cout<<endl<<"----------------------------------------------"<<endl;
}
void Composition( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    int tmp=a;
  if(b<a) tmp=b;
  vector <vector<int> > C9(A);///Создаем множество С8 равное множеству А
  for(int i=0;i<tmp;i++)
  {
      C9[i][1]=B[i][1]; ///заменяем вторые компоненты i-го кортежа графика С9 на вторые компоненты i-го кортежа графика В
  }
cout<<"композиция Г1 и Г2:"<<endl;
   cout<<"область отправления:"<<endl;
   for(int i=0; i<a_o; i++) cout<<A_O[i]<<" ";
   cout<<endl<<"область прибытия:"<<endl;
   for(int i=0; i<b_p; i++) cout<<B_P[i]<<" ";
cout<<endl<<"График соответствия:"<<endl;
   cout<<"{"; ///выводим композицию на экран
    for (int i = 0; i < tmp; i++)
    {
        cout<<"<";
        cout<<C9[i][0];
        cout<<",";
        cout<<C9[i][1];
        cout<<">";
    }
    cout<<"}"; ///выводим композицию на экран
    cout<<endl<<"----------------------------------------------"<<endl;
}

void obraz1( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    int n=0;
    cout<<"Введите мощность множества E: "; cin>>n;
    int *E; /// создаем множество A
    E= new int[n];
   cout<<endl<<"Введите элементы множества E: ";
   for(int i=0;i<n;i++) cin>>E[i];
   vector <vector<int> > D(n*a_p);

    int e=0;
    for(int i_a=0; i_a<n; i_a++) ///если i<a увеличиваем i на 1
        for(int i_b=0; i_b<a_p; i_b++) ///если j<b увеличиваем i на 1
        {
            D[e].push_back(E[i_a]);
            D[e].push_back(A_P[i_b]);
            e++;
        }


    vector <vector<int> > C;  ///cоздаем множество С
    //------------------------------------------------------------------------------

    for(int i=0; i<D.size(); i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<a; j++)///если j меньше b прибавляем к j единицу
        {
            if(D[i]==A[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {

                C.push_back(D[i]);///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    cout<<"{ ";
    for(int i=0;i<C.size();i++) cout<<C[i][1]<<" ";
    cout<<"}";
    cout<<endl<<"----------------------------------------------"<<endl;
    delete []E;
}

void proobraz1( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    int n=0;
    cout<<"Введите мощность множества E: "; cin>>n;
    int *E; /// создаем множество A
    E= new int[n];
   cout<<endl<<"Введите элементы множества E: ";
   for(int i=0;i<n;i++) cin>>E[i];
   vector <vector<int> > D(n*a_o);

    int e=0;
    for(int i_a=0; i_a<a_o; i_a++) ///если i<a увеличиваем i на 1
        for(int i_b=0; i_b<n; i_b++) ///если j<b увеличиваем i на 1
        {
            D[e].push_back(A_O[i_a]);
            D[e].push_back(E[i_b]);
            e++;
        }


    vector <vector<int> > C;  ///cоздаем множество С
    //------------------------------------------------------------------------------

    for(int i=0; i<D.size(); i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<a; j++)///если j меньше b прибавляем к j единицу
        {
            if(D[i]==A[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {
                C.push_back(D[i]);///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    cout<<"{ ";
    for(int i=0;i<C.size();i++) cout<<C[i][0]<<" ";
    cout<<"}";
    cout<<endl<<"----------------------------------------------"<<endl;
    delete []E;
}


void obraz2( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    int n=0;
    cout<<"Введите мощность множества E: "; cin>>n;
    int *E; /// создаем множество A
    E= new int[n];
   cout<<endl<<"Введите элементы множества E: ";
   for(int i=0;i<n;i++) cin>>E[i];
   vector <vector<int> > D(n*b_p);

    int e=0;
    for(int i_a=0; i_a<n; i_a++) ///если i<a увеличиваем i на 1
        for(int i_b=0; i_b<b_p; i_b++) ///если j<b увеличиваем i на 1
        {
            D[e].push_back(E[i_a]);
            D[e].push_back(B_P[i_b]);
            e++;
        }


    vector <vector<int> > C;  ///cоздаем множество С
    //------------------------------------------------------------------------------

    for(int i=0; i<n*b_p; i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b; j++)///если j меньше b прибавляем к j единицу
        {
            if(D[i]==B[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {

                C.push_back(D[i]);///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    cout<<"{ ";
    for(int i=0;i<C.size();i++) cout<<C[i][1]<<" ";
    cout<<"}";
    cout<<endl<<"----------------------------------------------"<<endl;
    delete []E;
}

void proobraz2( vector <vector<int> > A,vector <vector<int> > B,int a,int b,int *A_O,int a_o,int *A_P,int a_p,int *B_O,int b_o,int *B_P,int b_p)
{
    int n=0;
    cout<<"Введите мощность множества E: "; cin>>n;
    int *E; /// создаем множество A
    E= new int[n];
   cout<<endl<<"Введите элементы множества E: ";
   for(int i=0;i<n;i++) cin>>E[i];
   vector <vector<int> > D(n*b_o);

    int e=0;
    for(int i_a=0; i_a<b; i_a++) ///если i<a увеличиваем i на 1
        for(int i_b=0; i_b<n; i_b++) ///если j<b увеличиваем i на 1
        {
            D[e].push_back(B_O[i_a]);
            D[e].push_back(E[i_b]);
            e++;
        }


    vector <vector<int> > C;  ///cоздаем множество С
    //------------------------------------------------------------------------------

    for(int i=0; i<n*b_o; i++)///если i меньше а прибавляем к i единицу
    {
        for(int j=0; j<b_o; j++)///если j меньше b прибавляем к j единицу
        {
            if(D[i]==B[j])///Если i-й элемент множества A и j-й элемент множества B равны
            {
                C.push_back(D[i]);///добавляем i-й элемент в множество C
                break;
            }

        }

    }
    cout<<"{ ";
    for(int i=0;i<C.size();i++) cout<<C[i][0]<<" ";
    cout<<"}";
    cout<<endl<<"----------------------------------------------"<<endl;
    delete []E;
}


int main()
{
    bool kol=true;
    int *A_O,*B_O,*A_P,*B_P;
    setlocale(LC_ALL,"Russian");
    int tmp1=0,tmp2=0;


    ///---------------------------------------------------------------------------------------------------------------
    cout<<"введите мощность обсасти отправления соответствия Г1: ";
    int a_o; cin>>a_o;
    A_O= new int[a_o];  ///динамически выделяем память для множества А
    cout<<endl;
    cout<<"введите  обсасть отправления соответствия Г1: ";
    for (int i = 0; i < a_o; i++) cin>>A_O[i]; ///Пользователь задает элементы первого множества.
    cout<<endl;
    cout<<"введите мощность обсасти прибытия соответствия Г1: ";
    int a_p; cin>>a_p;
    A_P= new int[a_p];  ///динамически выделяем память для множества А
    cout<<endl;
    cout<<"введите  обсасть прибытия соответствия Г1: ";
    for (int i = 0; i < a_p; i++) cin>>A_P[i]; ///Пользователь задает элементы первого множества.
    cout<<endl;
    cout<<"Ведите мощность графика соответствия Г1: " ;
    int a;                                  ///Пользователь задает мощность множества A (a)
    cin>>a;
    vector <vector<int> > A(a);
    cout<<"введите кортежи графика соответствия Г1: ";
    cout<<endl;
    for (int i = 0; i < a; i++)
    {
        cout<<i+1<<" "<<"кортеж:";
        cout<<endl;
        tmp1=0;
        tmp2=0;
        cin>>tmp1;
        A[i].push_back(tmp1);
        cin>>tmp2;
        A[i].push_back(tmp2);
    }
    cout<<endl;
  ///---------------------------------------------------------------------------------------------------------------



  ///---------------------------------------------------------------------------------------------------------------
    cout<<"введите мощность обсасти отправления соответствия Г2: ";
    int b_o; cin>>b_o;
    B_O= new int[b_o];  ///динамически выделяем память для множества А
    cout<<endl;
    cout<<"введите  обсасть отправления соответствия Г2: ";
    for (int i = 0; i < b_o; i++) cin>>B_O[i]; ///Пользователь задает элементы первого множества.
    cout<<endl;
    cout<<"введите мощность обсасти прибытия соответствия Г2: ";
    int b_p; cin>>b_p;
    B_P= new int[b_p];  ///динамически выделяем память для множества А
    cout<<endl;
    cout<<"введите  обсасть прибытия соответствия Г2: ";
    for (int i = 0; i < b_p; i++) cin>>B_P[i]; ///Пользователь задает элементы первого множества.
    cout<<endl;
    cout<<"Ведите мощность графика соответствия Г2: ";
    int b;
    cin>>b;                                ///Пользователь задает мощность множестваB (b)
    vector <vector<int> > B(b);
    cout<<"введите кортежи графика соответствия Г2: ";
    cout<<endl;
    for (int i = 0; i < b; i++)
    {
        cout<<i+1<<" "<<"кортеж:";
        cout<<endl;
        tmp1=0;
        tmp2=0;
        cin>>tmp1;
        B[i].push_back(tmp1);
        cin>>tmp2;
        B[i].push_back(tmp2);
    }
    cout<<endl;


    ///---------------------------------------------------------------------------------------------------------------
    system("cls");


   ///---------------------------------------------------------------------------------------------------------------


    cout<<"обсасть отправления соответствия А: ";
    for (int i = 0; i < a_o; i++) cout<<A_O[i]<<" ";
    cout<<endl;
    cout<<"обсасть прибытия соответствия А: ";
    for (int i = 0; i < a_p; i++) cout<<A_P[i]<<" ";
    cout<<endl;
     cout<<"графика соответствия А: ";
    cout<<"{";
    for (int i = 0; i < a; i++)
    {
        cout<<"<";
        cout<<A[i][0];
        cout<<",";
        cout<<A[i][1];
        cout<<">";
    }
    cout<<"}";
    cout<<endl;
   ///---------------------------------------------------------------------------------------------------------------
    cout<<"обсасть отправления соответствия B: ";
    for (int i = 0; i < b_o; i++) cout<<B_O[i]<<" ";
    cout<<endl;
    cout<<"обсасть прибытия соответствия B: ";
    for (int i = 0; i < b_p; i++) cout<<B_P[i]<<" ";
    cout<<endl;
    cout<<"графика соответствия B: ";
    cout<<"{";
    for (int i = 0; i < b; i++)
    {
        cout<<"<";
        cout<<B[i][0];
        cout<<",";
        cout<<B[i][1];
        cout<<">";
    }
    cout<<"}";
    cout<<endl;
    ///---------------------------------------------------------------------------------------------------------
    cout<<endl;
     int in;
    ///Пользователь выбирает операцию над множествами-------------------------------------------------------------
        while(kol)
        {

            cout << "1.Операция пересечения АВ." << endl;
            cout << "2.Операция объединения АВ." << endl;
            cout << "3.Операция разность АВ." << endl;
            cout << "4.Операция инверсии А." << endl;
            cout << "5.Операция композиции АВ." <<endl;
            cout << "6.Операция симметрическоф разности." << endl;
            cout << "7.Операция образа Г1." << endl;
            cout << "8.Операция прообраза Г1." << endl;
            cout << "9.Операция образа Г2." << endl;
            cout << "10.Операция прообраза Г2." << endl;
            cout << "11.Завершить программу." << endl;
            cin >> in;
            switch (in)
            {
            case 1:
        {
            peresechenie(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///пересечение
            break;
        }
            case 2:
        {
            Obedinenie(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///объединение
            break;
        }
            case 3:
        {
            Raznost(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///разность
            break;
        }
        case 4:
        {
            inversion(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);      ///инверсия
            break;
        }
        case 5:
        {
            Composition(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///композиция
            break;
        }
        case 6:
        {
            sem_razn(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///симметрическая разность
            break;
        }
        case 7:
        {
            obraz1(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///симметрическая разность
            break;
        }
        case 8:
        {
            proobraz1(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///симметрическая разность
            break;
        }
        case 9:
        {
            obraz2(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///симметрическая разность
            break;
        }
        case 10:
        {
            proobraz2(A,B,a,b,A_O,a_o,A_P,a_p,B_O,b_o,B_P,b_p);    ///симметрическая разность
            break;
        }
        case 11:
        {
            kol=false;    ///завершение работы
            break;
        }
            default:
        {
            cout<<"Error!! ";    ///ошибка при вводе
            break;
        }
            }

        }
    ///---------------------------------------------------------------------------------------------------------




    return 0;
}
